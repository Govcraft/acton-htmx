//! Template definitions for scaffold code generation
//!
//! This module contains MiniJinja templates for generating:
//! - `SeaORM` models with validation
//! - Database migrations
//! - Form structs
//! - HTMX handlers
//! - Askama templates
//! - Integration tests
//! - Route registration
//!
//! Templates use Jinja2/MiniJinja syntax.

use anyhow::{Context, Result};
use minijinja::Environment;
use std::collections::HashMap;
use std::sync::Arc;

/// Template registry for scaffold code generation
pub struct TemplateRegistry {
    env: Environment<'static>,
    templates: Arc<HashMap<String, String>>,
}

impl TemplateRegistry {
    /// Create a new template registry with all scaffold templates registered
    ///
    /// Templates are embedded in the binary for reliability and offline use.
    /// User customization can be added later via XDG config directory override.
    ///
    /// # Errors
    ///
    /// Returns an error if the MiniJinja environment cannot be created.
    pub fn new() -> Result<Self> {
        let mut env = Environment::new();

        // Disable auto-escaping for code generation
        env.set_auto_escape_callback(|_| minijinja::AutoEscape::None);

        // Use embedded templates (MiniJinja/Jinja2 syntax)
        let mut templates = HashMap::new();
        templates.insert("model".to_string(), MODEL_TEMPLATE.to_string());
        templates.insert("migration".to_string(), MIGRATION_TEMPLATE.to_string());
        templates.insert("form".to_string(), FORM_TEMPLATE.to_string());
        templates.insert("handler".to_string(), HANDLER_TEMPLATE.to_string());
        templates.insert("test".to_string(), TEST_TEMPLATE.to_string());

        Ok(Self {
            env,
            templates: Arc::new(templates),
        })
    }

    /// Render a template with the given data
    ///
    /// # Errors
    ///
    /// Returns an error if the template name is not registered or if rendering fails.
    pub fn render(&self, template_name: &str, data: &serde_json::Value) -> Result<String> {
        let template_content = self
            .templates
            .get(template_name)
            .with_context(|| format!("Template not found: {template_name}"))?;

        self.env
            .render_str(template_content, data)
            .with_context(|| format!("Failed to render template: {template_name}"))
    }
}

impl Default for TemplateRegistry {
    fn default() -> Self {
        Self::new().expect("Failed to create template registry")
    }
}

// Template constants - will be populated in Week 2-3

/// `SeaORM` model template
pub const MODEL_TEMPLATE: &str = r#"//! {{ model_name }} model
//!
//! Generated by Acton HTMX scaffold

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
{%- if has_date_fields %}
use chrono::{NaiveDate, NaiveDateTime, DateTime, Utc};
{%- endif %}
{%- if has_decimal %}
use rust_decimal::Decimal;
{%- endif %}
{%- if has_uuid %}
use uuid::Uuid;
{%- endif %}
{%- if has_enum %}

{%- for enum in enums %}
/// {{ enum.name }} enumeration
#[derive(Debug, Clone, Copy, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(Some(50))")]
pub enum {{ enum.name }} {
    {%- for variant in enum.variants %}
    #[sea_orm(string_value = "{{ variant }}")]
    {{ variant }},
    {%- endfor %}
}
{%- endfor %}
{%- endif %}

/// {{ model_name }} entity
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "{{ table_name }}")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[serde(skip_deserializing)]
    pub id: i64,
    {%- for field in fields %}
    {%- if field.unique %}
    #[sea_orm(unique)]
    {%- endif %}
    {%- if field.indexed %}
    #[sea_orm(indexed)]
    {%- endif %}
    pub {{ field.name }}: {{ field.rust_type }},
    {%- endfor %}
    #[serde(skip_deserializing)]
    pub created_at: DateTime<Utc>,
    #[serde(skip_deserializing)]
    pub updated_at: DateTime<Utc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    {%- for relation in relations %}
    #[sea_orm(
        belongs_to = "super::{{ relation.referenced_table }}::Entity",
        from = "Column::{{ relation.field_column }}",
        to = "super::{{ relation.referenced_table }}::Column::Id"
    )]
    {{ relation.relation_name }},
    {%- endfor %}
}

{%- for relation in relations %}
impl Related<super::{{ relation.referenced_table }}::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::{{ relation.relation_name }}.def()
    }
}
{%- endfor %}

impl ActiveModelBehavior for ActiveModel {}

impl Entity {
    /// Find all {{ plural_title }}
    pub async fn find_all(db: &DatabaseConnection) -> Result<Vec<Model>, DbErr> {
        Self::find().all(db).await
    }

    /// Search {{ plural_title }} by query string
    ///
    /// Performs case-insensitive substring search across all text fields.
    /// Returns empty vector if query is empty or only whitespace.
    ///
    /// # Arguments
    ///
    /// * `db` - Database connection
    /// * `query` - Search query string
    ///
    /// # Examples
    ///
    /// ```no_run
    /// let results = Entity::search(&db, \"rust\").await?;
    /// ```
    pub async fn search(db: &DatabaseConnection, query: &str) -> Result<Vec<Model>, DbErr> {
        let query = query.trim();

        // Return empty vector for empty queries
        if query.is_empty() {
            return Ok(Vec::new());
        }

        // Build search pattern for LIKE query
        let search_pattern = format!(\"%{query}%\");

        // Build condition to search across all string fields
        let mut condition = Condition::any();
        {%- for field in fields %}
        {%- if field.rust_type == "String" %}
        condition = condition.add(Column::{{ field.pascal_case_name }}.like(&search_pattern));
        {%- elif field.rust_type == "Option<String>" %}
        condition = condition.add(Column::{{ field.pascal_case_name }}.like(&search_pattern));
        {%- endif %}
        {%- endfor %}

        Self::find()
            .filter(condition)
            .all(db)
            .await
    }

    /// Find {{ model_name }} by ID
    pub async fn find_by_id(db: &DatabaseConnection, id: i64) -> Result<Option<Model>, DbErr> {
        Self::find_by_id(id).one(db).await
    }

    /// Create new {{ model_name }}
    pub async fn create(db: &DatabaseConnection, form: super::forms::{{ model_name }}Form) -> Result<Model, DbErr> {
        let model = ActiveModel {
            {%- for field in fields %}
            {{ field.name }}: Set(form.{{ field.name }}),
            {%- endfor %}
            created_at: Set(Utc::now()),
            updated_at: Set(Utc::now()),
            ..Default::default()
        };
        model.insert(db).await
    }

    /// Update {{ model_name }}
    pub async fn update(db: &DatabaseConnection, id: i64, form: super::forms::{{ model_name }}Form) -> Result<Model, DbErr> {
        let model = Self::find_by_id(db, id).await?.ok_or(DbErr::RecordNotFound(id.to_string()))?;
        let mut active_model: ActiveModel = model.into();
        {%- for field in fields %}
        active_model.{{ field.name }} = Set(form.{{ field.name }});
        {%- endfor %}
        active_model.updated_at = Set(Utc::now());
        active_model.update(db).await
    }

    /// Delete {{ model_name }}
    pub async fn delete(db: &DatabaseConnection, id: i64) -> Result<DeleteResult, DbErr> {
        let model = Self::find_by_id(db, id).await?.ok_or(DbErr::RecordNotFound(id.to_string()))?;
        model.delete(db).await
    }
}
"#;

/// Database migration template
pub const MIGRATION_TEMPLATE: &str = r"-- Create {{ table_name }} table
-- Generated by Acton HTMX scaffold

CREATE TABLE {{ table_name }} (
    id BIGSERIAL PRIMARY KEY,
{%- for field in fields %}
    {{ field.column_name }} {{ field.sql_type }}{% if not field.optional %} NOT NULL{% endif %},
{%- endfor %}
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

{%- for field in unique_fields %}
-- Add unique constraint for {{ field.name }}
ALTER TABLE {{ table_name }} ADD CONSTRAINT {{ table_name }}_{{ field.name }}_unique UNIQUE ({{ field.column_name }});
{%- endfor %}

{%- for field in indexed_fields %}
-- Add index for {{ field.name }}
CREATE INDEX {{ table_name }}_{{ field.name }}_idx ON {{ table_name }} ({{ field.column_name }});
{%- endfor %}

{%- for fk in foreign_keys %}
-- Add foreign key for {{ fk.field_name }}
ALTER TABLE {{ table_name }}
    ADD CONSTRAINT {{ table_name }}_{{ fk.field_name }}_fkey
    FOREIGN KEY ({{ fk.column_name }})
    REFERENCES {{ fk.referenced_table }}(id)
    ON DELETE CASCADE;

-- Add index for foreign key
CREATE INDEX {{ table_name }}_{{ fk.field_name }}_idx ON {{ table_name }} ({{ fk.column_name }});
{%- endfor %}

-- Trigger to automatically update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_{{ table_name }}_updated_at
    BEFORE UPDATE ON {{ table_name }}
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
";

/// HTMX handler template
pub const HANDLER_TEMPLATE: &str = r#"//! {{ model_name }} handlers
//!
//! Generated by Acton HTMX scaffold

use acton_htmx::prelude::*;
use askama::Template;
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    Form,
};
use serde::Deserialize;
use validator::Validate;

use crate::{
    forms::{{ model_snake }}::{{ model_name }}Form,
    models::{{ model_snake }},
    state::AppState,
};

/// List all {{ plural_title }}
pub async fn list(
    State(state): State<AppState>,
    HxRequest(is_htmx): HxRequest,
    Query(params): Query<ListParams>,
) -> Result<Response, HandlerError> {
    let {{ model_snake }}s = {{ model_snake }}::Entity::find_all(&state.db).await?;

    let template = {{ model_name }}ListTemplate {
        {{ model_snake }}s,
        search_query: params.search.unwrap_or_default(),
    };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Show individual {{ model_name }}
pub async fn show(
    State(state): State<AppState>,
    HxRequest(is_htmx): HxRequest,
    Path(id): Path<i64>,
) -> Result<Response, HandlerError> {
    let {{ model_snake }} = {{ model_snake }}::Entity::find_by_id(&state.db, id)
        .await?
        .ok_or(HandlerError::NotFound)?;

    let template = {{ model_name }}ShowTemplate { {{ model_snake }} };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Show new {{ model_name }} form
pub async fn new(
    HxRequest(is_htmx): HxRequest,
) -> Result<Response, HandlerError> {
    let template = {{ model_name }}FormTemplate {
        {{ model_snake }}: None,
        errors: None,
    };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Create new {{ model_name }}
pub async fn create(
    State(state): State<AppState>,
    mut session: Session,
    Form(form): Form<{{ model_name }}Form>,
) -> Result<Response, HandlerError> {
    // Validate form
    if let Err(errors) = form.validate() {
        let template = {{ model_name }}FormTemplate {
            {{ model_snake }}: None,
            errors: Some(errors.into()),
        };
        return Ok((StatusCode::UNPROCESSABLE_ENTITY, template.render_partial()).into_response());
    }

    // Create {{ model_snake }}
    let {{ model_snake }} = {{ model_snake }}::Entity::create(&state.db, form).await?;

    // Add flash message
    session.add_flash(FlashMessage::success("{{ model_name }} created successfully!"));

    // Redirect to show page
    Ok(HxRedirect::to(&format!("{{ route_path }}/{}", {{ model_snake }}.id)).into_response())
}

/// Show edit {{ model_name }} form
pub async fn edit(
    State(state): State<AppState>,
    HxRequest(is_htmx): HxRequest,
    Path(id): Path<i64>,
) -> Result<Response, HandlerError> {
    let {{ model_snake }} = {{ model_snake }}::Entity::find_by_id(&state.db, id)
        .await?
        .ok_or(HandlerError::NotFound)?;

    let template = {{ model_name }}FormTemplate {
        {{ model_snake }}: Some({{ model_snake }}),
        errors: None,
    };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Update {{ model_name }}
pub async fn update(
    State(state): State<AppState>,
    mut session: Session,
    Path(id): Path<i64>,
    Form(form): Form<{{ model_name }}Form>,
) -> Result<Response, HandlerError> {
    // Validate form
    if let Err(errors) = form.validate() {
        let {{ model_snake }} = {{ model_snake }}::Entity::find_by_id(&state.db, id)
            .await?
            .ok_or(HandlerError::NotFound)?;

        let template = {{ model_name }}FormTemplate {
            {{ model_snake }}: Some({{ model_snake }}),
            errors: Some(errors.into()),
        };
        return Ok((StatusCode::UNPROCESSABLE_ENTITY, template.render_partial()).into_response());
    }

    // Update {{ model_snake }}
    let {{ model_snake }} = {{ model_snake }}::Entity::update(&state.db, id, form).await?;

    // Add flash message
    session.add_flash(FlashMessage::success("{{ model_name }} updated successfully!"));

    // Return updated row with OOB swap
    let row_template = {{ model_name }}RowTemplate { {{ model_snake }}: {{ model_snake }}.clone() };
    let flash_template = FlashMessagesTemplate { messages: session.take_flashes() };

    Ok(HxSwapOob::new()
        .inner_html(&format!(\"{{ model_snake }}-{}\", {{ model_snake }}.id), &row_template.render_partial())
        .inner_html(\"flash-messages\", &flash_template.render_partial())
        .into_response())
}

/// Delete {{ model_name }}
pub async fn delete(
    State(state): State<AppState>,
    mut session: Session,
    Path(id): Path<i64>,
) -> Result<Response, HandlerError> {
    {{ model_snake }}::Entity::delete(&state.db, id).await?;

    // Add flash message
    session.add_flash(FlashMessage::success("{{ model_name }} deleted successfully!"));

    // Return empty response with OOB swap to remove row and show flash
    let flash_template = FlashMessagesTemplate { messages: session.take_flashes() };

    Ok(HxSwapOob::new()
        .delete(&format!(\"{{ model_snake }}-{id}\"))
        .inner_html(\"flash-messages\", &flash_template.render_partial())
        .into_response())
}

/// Live search endpoint
///
/// Performs real-time search across {{ model_name }} text fields.
/// Returns filtered rows as HTML partial for HTMX swap.
pub async fn search(
    State(state): State<AppState>,
    Query(params): Query<SearchParams>,
) -> Result<Response, HandlerError> {
    let {{ model_snake }}s = {{ model_snake }}::Entity::search(&state.db, &params.q).await?;

    let template = {{ model_name }}RowsTemplate { {{ model_snake }}s };

    Ok(template.render_partial().into_response())
}

// Query parameters
#[derive(Debug, Deserialize)]
pub struct ListParams {
    pub search: Option<String>,
    pub page: Option<i64>,
}

#[derive(Debug, Deserialize)]
pub struct SearchParams {
    pub q: String,
}

// Templates
#[derive(Template)]
#[template(path = \"{{ model_snake }}s/list.html\")]
struct {{ model_name }}ListTemplate {
    {{ model_snake }}s: Vec<{{ model_snake }}::Model>,
    search_query: String,
}

#[derive(Template)]
#[template(path = \"{{ model_snake }}s/show.html\")]
struct {{ model_name }}ShowTemplate {
    {{ model_snake }}: {{ model_snake }}::Model,
}

#[derive(Template)]
#[template(path = \"{{ model_snake }}s/form.html\")]
struct {{ model_name }}FormTemplate {
    {{ model_snake }}: Option<{{ model_snake }}::Model>,
    errors: Option<ValidationErrors>,
}

#[derive(Template)]
#[template(path = \"{{ model_snake }}s/_row.html\")]
struct {{ model_name }}RowTemplate {
    {{ model_snake }}: {{ model_snake }}::Model,
}

#[derive(Template)]
#[template(path = \"{{ model_snake }}s/_rows.html\")]
struct {{ model_name }}RowsTemplate {
    {{ model_snake }}s: Vec<{{ model_snake }}::Model>,
}

#[derive(Template)]
#[template(path = \"partials/flash.html\")]
struct FlashMessagesTemplate {
    messages: Vec<FlashMessage>,
}

// Error handling
#[derive(Debug)]
pub enum HandlerError {
    Database(sea_orm::DbErr),
    NotFound,
}

impl From<sea_orm::DbErr> for HandlerError {
    fn from(err: sea_orm::DbErr) -> Self {
        Self::Database(err)
    }
}

impl IntoResponse for HandlerError {
    fn into_response(self) -> Response {
        match self {
            Self::Database(err) => {
                (StatusCode::INTERNAL_SERVER_ERROR, format!(\"Database error: {err}\")).into_response()
            }
            Self::NotFound => {
                (StatusCode::NOT_FOUND, \"Not found\").into_response()
            }
        }
    }
}
"#;

/// Form struct template
pub const FORM_TEMPLATE: &str = r"//! {{ model_name }} form validation
//!
//! Generated by Acton HTMX scaffold

use serde::{Deserialize, Serialize};
use validator::Validate;
{%- if has_date_fields %}
use chrono::{NaiveDate, NaiveDateTime, DateTime, Utc};
{%- endif %}
{%- if has_decimal %}
use rust_decimal::Decimal;
{%- endif %}
{%- if has_uuid %}
use uuid::Uuid;
{%- endif %}
{%- if has_enum %}
use super::models::{{ model_snake }}::{
    {%- for enum in enums %}
    {{ enum.name }},
    {%- endfor %}
};
{%- endif %}

/// {{ model_name }} form for creation and updates
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct {{ model_name }}Form {
    {%- for field in fields %}
    {%- if field.validations %}
    {%- for validation in field.validations %}
    #[validate({{ validation }})]
    {%- endfor %}
    {%- endif %}
    pub {{ field.name }}: {{ field.rust_type }},
    {%- endfor %}
}

impl {{ model_name }}Form {
    /// Create a new form instance
    pub fn new(
        {%- for field in fields %}
        {{ field.name }}: {{ field.rust_type }},
        {%- endfor %}
    ) -> Self {
        Self {
            {%- for field in fields %}
            {{ field.name }},
            {%- endfor %}
        }
    }

    /// Validate the form
    pub fn validate(&self) -> Result<(), validator::ValidationErrors> {
        Validate::validate(self)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_form_creation() {
        let form = {{ model_name }}Form::new(
            {%- for field in fields %}
            {%- if field.optional %}
            None,
            {%- else %}
            {{ field.default_value }},
            {%- endif %}
            {%- endfor %}
        );
        assert!(form.validate().is_ok());
    }
}
";

/// Integration test template
pub const TEST_TEMPLATE: &str = r#"//! Integration tests for {{ model_name }} CRUD operations
//!
//! Generated by Acton HTMX scaffold

use acton_htmx::prelude::*;
use axum::{
    body::Body,
    http::{Request, StatusCode},
};
use serde_json::json;
use tower::ServiceExt;

use crate::{
    models::{{ model_snake }},
    state::AppState,
    app_router,
};

#[tokio::test]
async fn test_list_{{ model_snake }}s() {
    let state = AppState::test().await;
    let app = app_router(state);

    let response = app
        .oneshot(
            Request::builder()
                .uri(\"{{ route_path }}\")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_create_{{ model_snake }}() {
    let state = AppState::test().await;
    let app = app_router(state.clone());

    // Create test {{ model_snake }}
    let form_data = serde_urlencoded::to_string(&json!({
        {%- for field in fields %}
        \"{{ field.name }}\": {% if field.optional %}null{% else %}{{ field.default_value }}{% endif %},
        {%- endfor %}
    }))
    .unwrap();

    let response = app
        .oneshot(
            Request::builder()
                .method(\"POST\")
                .uri(\"{{ route_path }}\")
                .header(\"content-type\", \"application/x-www-form-urlencoded\")
                .body(Body::from(form_data))
                .unwrap(),
        )
        .await
        .unwrap();

    // Should redirect after creation
    assert!(response.status().is_redirection() || response.status().is_success());

    // Verify {{ model_snake }} was created
    let {{ model_snake }}s = {{ model_snake }}::Entity::find_all(&state.db).await.unwrap();
    assert!(!{{ model_snake }}s.is_empty());
}

#[tokio::test]
async fn test_show_{{ model_snake }}() {
    let state = AppState::test().await;

    // Create test {{ model_snake }}
    let form = crate::forms::{{ model_snake }}::{{ model_name }}Form::new(
        {%- for field in fields %}
        {% if field.optional %}None{% else %}{{ field.default_value }}{% endif %},
        {%- endfor %}
    );
    let {{ model_snake }} = {{ model_snake }}::Entity::create(&state.db, form).await.unwrap();

    let app = app_router(state);

    let response = app
        .oneshot(
            Request::builder()
                .uri(&format!(\"{{ route_path }}/{}\", {{ model_snake }}.id))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_update_{{ model_snake }}() {
    let state = AppState::test().await;

    // Create test {{ model_snake }}
    let form = crate::forms::{{ model_snake }}::{{ model_name }}Form::new(
        {%- for field in fields %}
        {% if field.optional %}None{% else %}{{ field.default_value }}{% endif %},
        {%- endfor %}
    );
    let {{ model_snake }} = {{ model_snake }}::Entity::create(&state.db, form).await.unwrap();

    let app = app_router(state.clone());

    // Update {{ model_snake }}
    let form_data = serde_urlencoded::to_string(&json!({
        {%- for field in fields %}
        \"{{ field.name }}\": {% if field.optional %}null{% else %}{{ field.default_value }}{% endif %},
        {%- endfor %}
    }))
    .unwrap();

    let response = app
        .oneshot(
            Request::builder()
                .method(\"PUT\")
                .uri(&format!(\"{{ route_path }}/{}\", {{ model_snake }}.id))
                .header(\"content-type\", \"application/x-www-form-urlencoded\")
                .body(Body::from(form_data))
                .unwrap(),
        )
        .await
        .unwrap();

    assert!(response.status().is_success());

    // Verify {{ model_snake }} was updated
    let updated = {{ model_snake }}::Entity::find_by_id(&state.db, {{ model_snake }}.id)
        .await
        .unwrap()
        .expect(\"{{ model_name }} should exist\");
    assert_eq!(updated.id, {{ model_snake }}.id);
}

#[tokio::test]
async fn test_delete_{{ model_snake }}() {
    let state = AppState::test().await;

    // Create test {{ model_snake }}
    let form = crate::forms::{{ model_snake }}::{{ model_name }}Form::new(
        {%- for field in fields %}
        {% if field.optional %}None{% else %}{{ field.default_value }}{% endif %},
        {%- endfor %}
    );
    let {{ model_snake }} = {{ model_snake }}::Entity::create(&state.db, form).await.unwrap();

    let app = app_router(state.clone());

    let response = app
        .oneshot(
            Request::builder()
                .method(\"DELETE\")
                .uri(&format!(\"{{ route_path }}/{}\", {{ model_snake }}.id))
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert!(response.status().is_success());

    // Verify {{ model_snake }} was deleted
    let deleted = {{ model_snake }}::Entity::find_by_id(&state.db, {{ model_snake }}.id)
        .await
        .unwrap();
    assert!(deleted.is_none());
}

#[tokio::test]
async fn test_validation_errors() {
    let state = AppState::test().await;
    let app = app_router(state);

    // Attempt to create with invalid data
    let form_data = serde_urlencoded::to_string(&json!({})).unwrap();

    let response = app
        .oneshot(
            Request::builder()
                .method(\"POST\")
                .uri(\"{{ route_path }}\")
                .header(\"content-type\", \"application/x-www-form-urlencoded\")
                .body(Body::from(form_data))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::UNPROCESSABLE_ENTITY);
}
"#;

/// Askama template for list view
pub const ASKAMA_LIST_TEMPLATE: &str = r##"{% raw %}{% extends "base.html" %}

{% block title %}{% endraw %}{{ plural_title }}{% raw %}{% endblock %}

{% block content %}{% endraw %}
<!-- HTMX Content Start -->
<div id="main-content">
    <div class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold">{{ plural_title }}</h1>
            <a href="{{ route_path }}/new"
               class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
               hx-get="{{ route_path }}/new"
               hx-target="#main-content"
               hx-push-url="true">
                New {{ model_name }}
            </a>
        </div>

        <!-- Flash Messages -->
        <div id="flash-messages" class="mb-4"></div>

        <!-- Search Bar -->
        <div class="mb-4">
            <input type="search"
                   name="search"
                   placeholder="Search {{ plural_title }}..."
                   class="w-full px-4 py-2 border rounded"
                   hx-get="{{ route_path }}/search"
                   hx-trigger="keyup changed delay:500ms, search"
                   hx-target="#{{ model_snake }}-list"
                   hx-indicator=".htmx-indicator">
            <span class="htmx-indicator">Searching...</span>
        </div>

        <!-- {{ model_name }} List -->
        <div class="bg-white shadow-md rounded">
            <table class="min-w-full">
                <thead class="bg-gray-200">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">ID</th>
                        {%- for field in fields %}
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">{{ field.name }}</th>
                        {%- endfor %}
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Actions</th>
                    </tr>
                </thead>
                <tbody id="{{ model_snake }}-list" class="bg-white divide-y divide-gray-200">
                    {% raw %}{% for {% endraw %}{{ model_snake }}{% raw %} in {% endraw %}{{ model_snake }}{% raw %}s %}
                        {% include "{% endraw %}{{ model_snake }}{% raw %}s/_row.html" %}
                    {% endfor %}{% endraw %}
                </tbody>
            </table>
        </div>
    </div>
</div>
<!-- HTMX Content End -->
{% raw %}{% endblock %}{% endraw %}
"##;

/// Askama template for row partial
pub const ASKAMA_ROW_TEMPLATE: &str = r##"<tr id="{{ model_snake }}-{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}">
    <td class="px-6 py-4 whitespace-nowrap">{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}</td>
    {%- for field in fields %}
    <td class="px-6 py-4 whitespace-nowrap">{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.{% endraw %}{{ field.name }}{% raw %} }}{% endraw %}</td>
    {%- endfor %}
    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">
        <a href="{{ route_path }}/{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}"
           class="text-blue-600 hover:text-blue-900 mr-3"
           hx-get="{{ route_path }}/{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}"
           hx-target="#main-content"
           hx-push-url="true">
            View
        </a>
        <a href="{{ route_path }}/{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}/edit"
           class="text-indigo-600 hover:text-indigo-900 mr-3"
           hx-get="{{ route_path }}/{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}/edit"
           hx-target="#main-content"
           hx-push-url="true">
            Edit
        </a>
        <button class="text-red-600 hover:text-red-900"
                hx-delete="{{ route_path }}/{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}"
                hx-confirm="Are you sure you want to delete this {{ model_snake }}?"
                hx-target="#{{ model_snake }}-{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}"
                hx-swap="outerHTML swap:1s">
            Delete
        </button>
    </td>
</tr>
"##;

/// Askama template for rows partial (multiple rows for search)
pub const ASKAMA_ROWS_TEMPLATE: &str = r#"{% raw %}{% for {% endraw %}{{ model_snake }}{% raw %} in {% endraw %}{{ model_snake }}{% raw %}s %}
    {% include "{% endraw %}{{ model_snake }}{% raw %}s/_row.html" %}
{% endfor %}{% endraw %}
"#;

/// Askama template for show view
pub const ASKAMA_SHOW_TEMPLATE: &str = r##"{% raw %}{% extends "base.html" %}

{% block title %}{% endraw %}{{ model_name }} #{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endblock %}

{% block content %}{% endraw %}
<!-- HTMX Content Start -->
<div id="main-content">
    <div class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold">{{ model_name }} #{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}</h1>
            <div>
                <a href="{{ route_path }}/{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}/edit"
                   class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mr-2"
                   hx-get="{{ route_path }}/{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.id }}{% endraw %}/edit"
                   hx-target="#main-content"
                   hx-push-url="true">
                    Edit
                </a>
                <a href="{{ route_path }}"
                   class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded"
                   hx-get="{{ route_path }}"
                   hx-target="#main-content"
                   hx-push-url="true">
                    Back to List
                </a>
            </div>
        </div>

        <!-- Flash Messages -->
        <div id="flash-messages" class="mb-4"></div>

        <div class="bg-white shadow-md rounded px-8 py-6">
            {%- for field in fields %}
            <div class="mb-4">
                <label class="block text-gray-700 text-sm font-bold mb-2">{{ field.name }}:</label>
                <p class="text-gray-900">{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.{% endraw %}{{ field.name }}{% raw %} }}{% endraw %}</p>
            </div>
            {%- endfor %}
            <div class="mb-4">
                <label class="block text-gray-700 text-sm font-bold mb-2">Created At:</label>
                <p class="text-gray-900">{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.created_at }}{% endraw %}</p>
            </div>
            <div class="mb-4">
                <label class="block text-gray-700 text-sm font-bold mb-2">Updated At:</label>
                <p class="text-gray-900">{% raw %}{{ {% endraw %}{{ model_snake }}{% raw %}.updated_at }}{% endraw %}</p>
            </div>
        </div>
    </div>
</div>
<!-- HTMX Content End -->
{% raw %}{% endblock %}{% endraw %}
"##;

/// Askama template for form view (new and edit)
pub const ASKAMA_FORM_TEMPLATE: &str = r##"{% raw %}{% extends "base.html" %}

{% block title %}{% if {% endraw %}{{ model_snake }}{% raw %} %}Edit{% else %}New{% endif %} {% endraw %}{{ model_name }}{% raw %}{% endblock %}

{% block content %}{% endraw %}
<!-- HTMX Content Start -->
<div id="main-content">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-6">{% raw %}{% if {% endraw %}{{ model_snake }}{% raw %} %}Edit{% else %}New{% endif %}{% endraw %} {{ model_name }}</h1>

        <!-- Flash Messages -->
        <div id="flash-messages" class="mb-4"></div>

        <div class="bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4">
            <form {% raw %}{% if {% endraw %}{{ model_snake }}{% raw %} %}
                      hx-put="{% endraw %}{{ route_path }}{% raw %}/{{ {% endraw %}{{ model_snake }}{% raw %}.id }}"
                  {% else %}
                      hx-post="{% endraw %}{{ route_path }}{% raw %}"
                  {% endif %}{% endraw %}
                  hx-target="#main-content"
                  hx-push-url="true">

                {%- for field in fields %}
                <div class="mb-4">
                    <label for="{{ field.name }}" class="block text-gray-700 text-sm font-bold mb-2">
                        {{ field.name }}{% if not field.optional %}*{% endif %}
                    </label>
                    {%- if field.rust_type == "String" %}
                    <input type="text"
                           name="{{ field.name }}"
                           id="{{ field.name }}"
                           value="{% raw %}{% if {% endraw %}{{ model_snake }}{% raw %} %}{{ {% endraw %}{{ model_snake }}{% raw %}.{% endraw %}{{ field.name }}{% raw %} }}{% endif %}{% endraw %}"
                           class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline {% raw %}{% if errors %}{% if errors.{% endraw %}{{ field.name }}{% raw %} %}border-red-500{% endif %}{% endif %}{% endraw %}"
                           {% if not field.optional %}required{% endif %}>
                    {%- elif field.rust_type == "bool" %}
                    <input type="checkbox"
                           name="{{ field.name }}"
                           id="{{ field.name }}"
                           {% raw %}{% if {% endraw %}{{ model_snake }}{% raw %} %}{% if {% endraw %}{{ model_snake }}{% raw %}.{% endraw %}{{ field.name }}{% raw %} %}checked{% endif %}{% endif %}{% endraw %}
                           class="mr-2 leading-tight">
                    {%- else %}
                    <input type="text"
                           name="{{ field.name }}"
                           id="{{ field.name }}"
                           value="{% raw %}{% if {% endraw %}{{ model_snake }}{% raw %} %}{{ {% endraw %}{{ model_snake }}{% raw %}.{% endraw %}{{ field.name }}{% raw %} }}{% endif %}{% endraw %}"
                           class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline {% raw %}{% if errors %}{% if errors.{% endraw %}{{ field.name }}{% raw %} %}border-red-500{% endif %}{% endif %}{% endraw %}"
                           {% if not field.optional %}required{% endif %}>
                    {%- endif %}
                    {% raw %}{% if errors %}
                        {% if let Some(field_errors) = errors.{% endraw %}{{ field.name }}{% raw %} %}
                            <p class="text-red-500 text-xs italic mt-1">{{ field_errors[0] }}</p>
                        {% endif %}
                    {% endif %}{% endraw %}
                </div>
                {%- endfor %}

                <div class="flex items-center justify-between">
                    <button type="submit"
                            class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                        {% raw %}{% if {% endraw %}{{ model_snake }}{% raw %} %}Update{% else %}Create{% endif %}{% endraw %} {{ model_name }}
                    </button>
                    <a href="{{ route_path }}"
                       class="inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800"
                       hx-get="{{ route_path }}"
                       hx-target="#main-content"
                       hx-push-url="true">
                        Cancel
                    </a>
                </div>
            </form>
        </div>
    </div>
</div>
<!-- HTMX Content End -->
{% raw %}{% endblock %}{% endraw %}
"##;
