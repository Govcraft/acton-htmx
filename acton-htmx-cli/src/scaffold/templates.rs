//! Template definitions for scaffold code generation
//!
//! This module contains Handlebars templates for generating:
//! - SeaORM models with validation
//! - Database migrations
//! - Form structs
//! - HTMX handlers
//! - Askama templates
//! - Integration tests
//! - Route registration
//!
//! Templates use Handlebars syntax with custom helpers for naming conventions.

use handlebars::Handlebars;
use anyhow::Result;

/// Template registry for scaffold code generation
pub struct TemplateRegistry {
    handlebars: Handlebars<'static>,
}

impl TemplateRegistry {
    /// Create a new template registry with all scaffold templates registered
    pub fn new() -> Result<Self> {
        let mut handlebars = Handlebars::new();

        // Disable HTML escaping for code generation
        handlebars.register_escape_fn(handlebars::no_escape);

        // Register templates
        handlebars.register_template_string("model", MODEL_TEMPLATE)?;
        handlebars.register_template_string("migration", MIGRATION_TEMPLATE)?;
        handlebars.register_template_string("form", FORM_TEMPLATE)?;
        handlebars.register_template_string("handler", HANDLER_TEMPLATE)?;
        handlebars.register_template_string("test", TEST_TEMPLATE)?;

        Ok(Self { handlebars })
    }

    /// Render a template with the given data
    pub fn render(&self, template_name: &str, data: &serde_json::Value) -> Result<String> {
        Ok(self.handlebars.render(template_name, data)?)
    }
}

impl Default for TemplateRegistry {
    fn default() -> Self {
        Self::new().expect("Failed to create template registry")
    }
}

// Template constants - will be populated in Week 2-3

/// SeaORM model template
pub const MODEL_TEMPLATE: &str = r#"//! {{model_name}} model
//!
//! Generated by acton-htmx scaffold

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
{{#if has_date_fields}}
use chrono::{NaiveDate, NaiveDateTime, DateTime, Utc};
{{/if}}
{{#if has_decimal}}
use rust_decimal::Decimal;
{{/if}}
{{#if has_uuid}}
use uuid::Uuid;
{{/if}}
{{#if has_enum}}

{{#each enums}}
/// {{name}} enumeration
#[derive(Debug, Clone, Copy, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize)]
#[sea_orm(rs_type = "String", db_type = "String(Some(50))")]
pub enum {{name}} {
    {{#each variants}}
    #[sea_orm(string_value = "{{this}}")]
    {{this}},
    {{/each}}
}
{{/each}}
{{/if}}

/// {{model_name}} entity
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "{{table_name}}")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[serde(skip_deserializing)]
    pub id: i64,
    {{#each fields}}
    {{#if unique}}
    #[sea_orm(unique)]
    {{/if}}
    {{#if indexed}}
    #[sea_orm(indexed)]
    {{/if}}
    pub {{name}}: {{rust_type}},
    {{/each}}
    #[serde(skip_deserializing)]
    pub created_at: DateTime<Utc>,
    #[serde(skip_deserializing)]
    pub updated_at: DateTime<Utc>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    {{#each relations}}
    #[sea_orm(
        belongs_to = "super::{{referenced_table}}::Entity",
        from = "Column::{{field_column}}",
        to = "super::{{referenced_table}}::Column::Id"
    )]
    {{relation_name}},
    {{/each}}
}

{{#each relations}}
impl Related<super::{{referenced_table}}::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::{{relation_name}}.def()
    }
}
{{/each}}

impl ActiveModelBehavior for ActiveModel {}

impl Entity {
    /// Find all {{plural_title}}
    pub async fn find_all(db: &DatabaseConnection) -> Result<Vec<Model>, DbErr> {
        Self::find().all(db).await
    }

    /// Find {{model_name}} by ID
    pub async fn find_by_id(db: &DatabaseConnection, id: i64) -> Result<Option<Model>, DbErr> {
        Self::find_by_id(id).one(db).await
    }

    /// Create new {{model_name}}
    pub async fn create(db: &DatabaseConnection, form: super::forms::{{model_name}}Form) -> Result<Model, DbErr> {
        let model = ActiveModel {
            {{#each fields}}
            {{name}}: Set(form.{{name}}),
            {{/each}}
            created_at: Set(Utc::now()),
            updated_at: Set(Utc::now()),
            ..Default::default()
        };
        model.insert(db).await
    }

    /// Update {{model_name}}
    pub async fn update(db: &DatabaseConnection, id: i64, form: super::forms::{{model_name}}Form) -> Result<Model, DbErr> {
        let model = Self::find_by_id(db, id).await?.ok_or(DbErr::RecordNotFound(id.to_string()))?;
        let mut active_model: ActiveModel = model.into();
        {{#each fields}}
        active_model.{{name}} = Set(form.{{name}});
        {{/each}}
        active_model.updated_at = Set(Utc::now());
        active_model.update(db).await
    }

    /// Delete {{model_name}}
    pub async fn delete(db: &DatabaseConnection, id: i64) -> Result<DeleteResult, DbErr> {
        let model = Self::find_by_id(db, id).await?.ok_or(DbErr::RecordNotFound(id.to_string()))?;
        model.delete(db).await
    }
}
"#;

/// Database migration template
pub const MIGRATION_TEMPLATE: &str = r#"-- Create {{table_name}} table
-- Generated by acton-htmx scaffold

CREATE TABLE {{table_name}} (
    id BIGSERIAL PRIMARY KEY,
    {{#each fields}}
    {{column_name}} {{sql_type}}{{#unless optional}} NOT NULL{{/unless}},
    {{/each}}
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

{{#each unique_fields}}
-- Add unique constraint for {{name}}
ALTER TABLE {{../table_name}} ADD CONSTRAINT {{../table_name}}_{{name}}_unique UNIQUE ({{column_name}});
{{/each}}

{{#each indexed_fields}}
-- Add index for {{name}}
CREATE INDEX {{../table_name}}_{{name}}_idx ON {{../table_name}} ({{column_name}});
{{/each}}

{{#each foreign_keys}}
-- Add foreign key for {{field_name}}
ALTER TABLE {{../table_name}}
    ADD CONSTRAINT {{../table_name}}_{{field_name}}_fkey
    FOREIGN KEY ({{column_name}})
    REFERENCES {{referenced_table}}(id)
    ON DELETE CASCADE;

-- Add index for foreign key
CREATE INDEX {{../table_name}}_{{field_name}}_idx ON {{../table_name}} ({{column_name}});
{{/each}}

-- Trigger to automatically update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_{{table_name}}_updated_at
    BEFORE UPDATE ON {{table_name}}
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
"#;

/// HTMX handler template (to be implemented in Week 3)
pub const HANDLER_TEMPLATE: &str = r"
// TODO: HTMX handler template
";

/// Form struct template
pub const FORM_TEMPLATE: &str = r#"//! {{model_name}} form validation
//!
//! Generated by acton-htmx scaffold

use serde::{Deserialize, Serialize};
use validator::Validate;
{{#if has_date_fields}}
use chrono::{NaiveDate, NaiveDateTime, DateTime, Utc};
{{/if}}
{{#if has_decimal}}
use rust_decimal::Decimal;
{{/if}}
{{#if has_uuid}}
use uuid::Uuid;
{{/if}}
{{#if has_enum}}
use super::models::{{model_snake}}::{
    {{#each enums}}
    {{name}},
    {{/each}}
};
{{/if}}

/// {{model_name}} form for creation and updates
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct {{model_name}}Form {
    {{#each fields}}
    {{#if validations}}
    {{#each validations}}
    #[validate({{this}})]
    {{/each}}
    {{/if}}
    pub {{name}}: {{rust_type}},
    {{/each}}
}

impl {{model_name}}Form {
    /// Create a new form instance
    pub fn new(
        {{#each fields}}
        {{name}}: {{rust_type}},
        {{/each}}
    ) -> Self {
        Self {
            {{#each fields}}
            {{name}},
            {{/each}}
        }
    }

    /// Validate the form
    pub fn validate(&self) -> Result<(), validator::ValidationErrors> {
        Validate::validate(self)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_form_creation() {
        let form = {{model_name}}Form::new(
            {{#each fields}}
            {{#if optional}}
            None,
            {{else}}
            {{default_value}},
            {{/if}}
            {{/each}}
        );
        assert!(form.validate().is_ok());
    }
}
"#;

/// Integration test template (to be implemented in Week 3)
pub const TEST_TEMPLATE: &str = r"
// TODO: Integration test template
";
