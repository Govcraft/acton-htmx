//! Authentication handlers with `SQLite` database integration
//!
//! Provides login, registration, and logout functionality with:
//! - Argon2id password hashing
//! - Session-based authentication
//! - Flash messages for user feedback
//! - Form validation

use crate::AppState;
use acton_dx::prelude::*;
use acton_dx::auth::{FlashMessage, hash_password, verify_password};
use askama::Template;
use axum::{
    extract::State,
    response::{Html, IntoResponse, Response},
    Form,
};
use axum_htmx::HxRedirect;
use serde::Deserialize;

/// User row from `SQLite` database
#[derive(Debug, Clone, sqlx::FromRow)]
struct UserRow {
    id: i64,
    #[allow(dead_code)]
    email: String,
    password_hash: String,
}

// =============================================================================
// Templates
// =============================================================================

#[derive(Template)]
#[template(path = "auth/login.html")]
pub struct LoginTemplate {
    pub user_id: Option<i64>,
    pub error: Option<String>,
    pub flash_messages: Vec<FlashMessage>,
}

#[derive(Template)]
#[template(path = "auth/register.html")]
pub struct RegisterTemplate {
    pub user_id: Option<i64>,
    pub error: Option<String>,
    pub flash_messages: Vec<FlashMessage>,
}

// =============================================================================
// Form Data
// =============================================================================

#[derive(Debug, Deserialize)]
pub struct LoginForm {
    pub email: String,
    pub password: String,
}

#[derive(Debug, Deserialize)]
pub struct RegisterForm {
    pub email: String,
    pub password: String,
    pub password_confirm: String,
}

// =============================================================================
// Handlers
// =============================================================================

/// GET /login - Show login form
pub async fn login_form(
    session: SessionExtractor,
) -> Html<String> {
    let template = LoginTemplate {
        user_id: session.1.user_id,
        error: None,
        flash_messages: session.1.flash_messages,
    };
    Html(template.render().unwrap())
}

/// POST /login - Process login
pub async fn login(
    State(state): State<AppState>,
    mut session: SessionExtractor,
    Form(form): Form<LoginForm>,
) -> Response {
    // Validate form
    if form.email.is_empty() || form.password.is_empty() {
        let template = LoginTemplate {
            user_id: None,
            error: Some("Email and password are required".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    // Find user by email
    let user = match sqlx::query_as::<_, UserRow>(
        "SELECT id, email, password_hash FROM users WHERE email = ?"
    )
    .bind(form.email.to_lowercase())
    .fetch_optional(state.db())
    .await
    {
        Ok(Some(user)) => user,
        Ok(None) => {
            let template = LoginTemplate {
                user_id: None,
                error: Some("Invalid email or password".to_string()),
                flash_messages: vec![],
            };
            return Html(template.render().unwrap()).into_response();
        }
        Err(e) => {
            tracing::error!("Database error during login: {}", e);
            let template = LoginTemplate {
                user_id: None,
                error: Some("An error occurred. Please try again.".to_string()),
                flash_messages: vec![],
            };
            return Html(template.render().unwrap()).into_response();
        }
    };

    // Verify password
    if matches!(verify_password(&form.password, &user.password_hash), Ok(true)) {
        // Set user ID in session
        session.1.user_id = Some(user.id);
        session.1.flash_messages.push(FlashMessage::success("Successfully logged in!"));
        // Use HxRedirect for HTMX-aware redirect
        (HxRedirect::from("/"), Html(String::new())).into_response()
    } else {
        let template = LoginTemplate {
            user_id: None,
            error: Some("Invalid email or password".to_string()),
            flash_messages: vec![],
        };
        Html(template.render().unwrap()).into_response()
    }
}

/// GET /register - Show registration form
pub async fn register_form(
    session: SessionExtractor,
) -> Html<String> {
    let template = RegisterTemplate {
        user_id: session.1.user_id,
        error: None,
        flash_messages: session.1.flash_messages,
    };
    Html(template.render().unwrap())
}

/// POST /register - Process registration
pub async fn register(
    State(state): State<AppState>,
    mut session: SessionExtractor,
    Form(form): Form<RegisterForm>,
) -> Response {
    // Validate form
    if form.email.is_empty() {
        let template = RegisterTemplate {
            user_id: None,
            error: Some("Email is required".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    if form.password.len() < 8 {
        let template = RegisterTemplate {
            user_id: None,
            error: Some("Password must be at least 8 characters".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    if form.password != form.password_confirm {
        let template = RegisterTemplate {
            user_id: None,
            error: Some("Passwords do not match".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    // Check if email already exists
    let exists = sqlx::query_scalar::<_, i32>(
        "SELECT 1 FROM users WHERE email = ?"
    )
    .bind(form.email.to_lowercase())
    .fetch_optional(state.db())
    .await;

    if matches!(exists, Ok(Some(_))) {
        let template = RegisterTemplate {
            user_id: None,
            error: Some("Email already registered".to_string()),
            flash_messages: vec![],
        };
        return Html(template.render().unwrap()).into_response();
    }

    // Hash password
    let password_hash = match hash_password(&form.password) {
        Ok(hash) => hash,
        Err(e) => {
            tracing::error!("Password hashing failed: {}", e);
            let template = RegisterTemplate {
                user_id: None,
                error: Some("An error occurred. Please try again.".to_string()),
                flash_messages: vec![],
            };
            return Html(template.render().unwrap()).into_response();
        }
    };

    // Create user
    let result = sqlx::query(
        r#"
        INSERT INTO users (email, password_hash, roles, permissions, email_verified)
        VALUES (?, ?, '["user"]', '[]', 0)
        "#
    )
    .bind(form.email.to_lowercase())
    .bind(&password_hash)
    .execute(state.db())
    .await;

    match result {
        Ok(result) => {
            let user_id = result.last_insert_rowid();

            // Auto-login after registration
            session.1.user_id = Some(user_id);
            session.1.flash_messages.push(FlashMessage::success("Account created successfully! Welcome!"));
            // Use HxRedirect for HTMX-aware redirect
            (HxRedirect::from("/"), Html(String::new())).into_response()
        }
        Err(e) => {
            tracing::error!("Failed to create user: {}", e);
            let template = RegisterTemplate {
                user_id: None,
                error: Some("Failed to create account. Please try again.".to_string()),
                flash_messages: vec![],
            };
            Html(template.render().unwrap()).into_response()
        }
    }
}

/// POST /logout - Clear session and logout
pub async fn logout(
    mut session: SessionExtractor,
) -> Response {
    // Clear user ID from session
    session.1.user_id = None;
    session.1.flash_messages.push(FlashMessage::info("You have been logged out."));
    // Use HxRedirect for HTMX-aware redirect
    (HxRedirect::from("/login"), Html(String::new())).into_response()
}
