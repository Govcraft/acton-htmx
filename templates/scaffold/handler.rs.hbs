//! {{model_name}} handlers
//!
//! Generated by acton-dx scaffold

use acton_dx::prelude::*;
use askama::Template;
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    Form,
};
use serde::Deserialize;
use validator::Validate;

use crate::{
    forms::{{model_snake}}::{{model_name}}Form,
    models::{{model_snake}},
    state::AppState,
};

/// List all {{plural_title}}
pub async fn list(
    State(state): State<AppState>,
    HxRequest(is_htmx): HxRequest,
    Query(params): Query<ListParams>,
) -> Result<Response, HandlerError> {
    let {{model_snake}}s = {{model_snake}}::Entity::find_all(&state.db).await?;

    let template = {{model_name}}ListTemplate {
        {{model_snake}}s,
        search_query: params.search.unwrap_or_default(),
    };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Show individual {{model_name}}
pub async fn show(
    State(state): State<AppState>,
    HxRequest(is_htmx): HxRequest,
    Path(id): Path<i64>,
) -> Result<Response, HandlerError> {
    let {{model_snake}} = {{model_snake}}::Entity::find_by_id(&state.db, id)
        .await?
        .ok_or(HandlerError::NotFound)?;

    let template = {{model_name}}ShowTemplate { {{model_snake}} };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Show new {{model_name}} form
pub async fn new(
    HxRequest(is_htmx): HxRequest,
) -> Result<Response, HandlerError> {
    let template = {{model_name}}FormTemplate {
        {{model_snake}}: None,
        errors: None,
    };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Create new {{model_name}}
pub async fn create(
    State(state): State<AppState>,
    mut session: Session,
    Form(form): Form<{{model_name}}Form>,
) -> Result<Response, HandlerError> {
    // Validate form
    if let Err(errors) = form.validate() {
        let template = {{model_name}}FormTemplate {
            {{model_snake}}: None,
            errors: Some(errors.into()),
        };
        return Ok((StatusCode::UNPROCESSABLE_ENTITY, template.render_partial()).into_response());
    }

    // Create {{model_snake}}
    let {{model_snake}} = {{model_snake}}::Entity::create(&state.db, form).await?;

    // Add flash message
    session.add_flash(FlashMessage::success("{{model_name}} created successfully!"));

    // Redirect to show page
    Ok(HxRedirect::to(&format!("{{route_path}}/{}", {{model_snake}}.id)).into_response())
}

/// Show edit {{model_name}} form
pub async fn edit(
    State(state): State<AppState>,
    HxRequest(is_htmx): HxRequest,
    Path(id): Path<i64>,
) -> Result<Response, HandlerError> {
    let {{model_snake}} = {{model_snake}}::Entity::find_by_id(&state.db, id)
        .await?
        .ok_or(HandlerError::NotFound)?;

    let template = {{model_name}}FormTemplate {
        {{model_snake}}: Some({{model_snake}}),
        errors: None,
    };

    Ok(template.render_htmx(is_htmx).into_response())
}

/// Update {{model_name}}
pub async fn update(
    State(state): State<AppState>,
    mut session: Session,
    Path(id): Path<i64>,
    Form(form): Form<{{model_name}}Form>,
) -> Result<Response, HandlerError> {
    // Validate form
    if let Err(errors) = form.validate() {
        let {{model_snake}} = {{model_snake}}::Entity::find_by_id(&state.db, id)
            .await?
            .ok_or(HandlerError::NotFound)?;

        let template = {{model_name}}FormTemplate {
            {{model_snake}}: Some({{model_snake}}),
            errors: Some(errors.into()),
        };
        return Ok((StatusCode::UNPROCESSABLE_ENTITY, template.render_partial()).into_response());
    }

    // Update {{model_snake}}
    let {{model_snake}} = {{model_snake}}::Entity::update(&state.db, id, form).await?;

    // Add flash message
    session.add_flash(FlashMessage::success("{{model_name}} updated successfully!"));

    // Return updated row with OOB swap
    let row_template = {{model_name}}RowTemplate { {{model_snake}}: {{model_snake}}.clone() };
    let flash_template = FlashMessagesTemplate { messages: session.take_flashes() };

    Ok(HxSwapOob::new()
        .inner_html(&format!("{{model_snake}}-{}", {{model_snake}}.id), &row_template.render_partial())
        .inner_html("flash-messages", &flash_template.render_partial())
        .into_response())
}

/// Delete {{model_name}}
pub async fn delete(
    State(state): State<AppState>,
    mut session: Session,
    Path(id): Path<i64>,
) -> Result<Response, HandlerError> {
    {{model_snake}}::Entity::delete(&state.db, id).await?;

    // Add flash message
    session.add_flash(FlashMessage::success("{{model_name}} deleted successfully!"));

    // Return empty response with OOB swap to remove row and show flash
    let flash_template = FlashMessagesTemplate { messages: session.take_flashes() };

    Ok(HxSwapOob::new()
        .delete(&format!("{{model_snake}}-{id}"))
        .inner_html("flash-messages", &flash_template.render_partial())
        .into_response())
}

/// Live search endpoint
///
/// Performs real-time search across {{model_name}} text fields.
/// Returns filtered rows as HTML partial for HTMX swap.
pub async fn search(
    State(state): State<AppState>,
    Query(params): Query<SearchParams>,
) -> Result<Response, HandlerError> {
    let {{model_snake}}s = {{model_snake}}::Entity::search(&state.db, &params.q).await?;

    let template = {{model_name}}RowsTemplate { {{model_snake}}s };

    Ok(template.render_partial().into_response())
}

// Query parameters
#[derive(Debug, Deserialize)]
pub struct ListParams {
    pub search: Option<String>,
    pub page: Option<i64>,
}

#[derive(Debug, Deserialize)]
pub struct SearchParams {
    pub q: String,
}

// Templates
#[derive(Template)]
#[template(path = "{{model_snake}}s/list.html")]
struct {{model_name}}ListTemplate {
    {{model_snake}}s: Vec<{{model_snake}}::Model>,
    search_query: String,
}

#[derive(Template)]
#[template(path = "{{model_snake}}s/show.html")]
struct {{model_name}}ShowTemplate {
    {{model_snake}}: {{model_snake}}::Model,
}

#[derive(Template)]
#[template(path = "{{model_snake}}s/form.html")]
struct {{model_name}}FormTemplate {
    {{model_snake}}: Option<{{model_snake}}::Model>,
    errors: Option<ValidationErrors>,
}

#[derive(Template)]
#[template(path = "{{model_snake}}s/_row.html")]
struct {{model_name}}RowTemplate {
    {{model_snake}}: {{model_snake}}::Model,
}

#[derive(Template)]
#[template(path = "{{model_snake}}s/_rows.html")]
struct {{model_name}}RowsTemplate {
    {{model_snake}}s: Vec<{{model_snake}}::Model>,
}

#[derive(Template)]
#[template(path = "partials/flash.html")]
struct FlashMessagesTemplate {
    messages: Vec<FlashMessage>,
}

// Error handling
#[derive(Debug)]
pub enum HandlerError {
    Database(sea_orm::DbErr),
    NotFound,
}

impl From<sea_orm::DbErr> for HandlerError {
    fn from(err: sea_orm::DbErr) -> Self {
        Self::Database(err)
    }
}

impl IntoResponse for HandlerError {
    fn into_response(self) -> Response {
        match self {
            Self::Database(err) => {
                (StatusCode::INTERNAL_SERVER_ERROR, format!("Database error: {err}")).into_response()
            }
            Self::NotFound => {
                (StatusCode::NOT_FOUND, "Not found").into_response()
            }
        }
    }
}
